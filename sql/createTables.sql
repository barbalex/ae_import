-- data_type is used for root nodes in app's tree
-- actually: is not used in app, values are directly set :-(
DROP TABLE IF EXISTS ae.data_type CASCADE;
CREATE TABLE ae.data_type (
  name text PRIMARY KEY
);
INSERT INTO ae.data_type VALUES ('Taxonomien'), ('Eigenschaften-Sammlungen');

DROP TABLE IF EXISTS ae.category CASCADE;
CREATE TABLE ae.category (
  name text PRIMARY KEY,
  -- data_type is used to attach categories to root node in app's tree
  data_type text DEFAULT 'Taxonomien' REFERENCES ae.data_type (name) ON DELETE SET NULL ON UPDATE CASCADE,
  id UUID DEFAULT uuid_generate_v1mc()
);

DROP TABLE IF EXISTS ae.organization CASCADE;
CREATE TABLE ae.organization (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v1mc(),
  name text UNIQUE NOT NULL
);
CREATE INDEX ON ae.organization USING btree (name);

DROP TABLE IF EXISTS ae.taxonomy CASCADE;
CREATE TABLE ae.taxonomy (
  -- gets existing guids
  id UUID PRIMARY KEY DEFAULT uuid_generate_v1mc(),
  name text UNIQUE NOT NULL,
  description text DEFAULT NULL,
  links text[] DEFAULT NULL,
  last_updated date DEFAULT NULL,
  organization_id UUID NOT NULL REFERENCES ae.organization (id) ON DELETE SET NULL ON UPDATE CASCADE,
  is_category_standard boolean DEFAULT FALSE,
  imported_by UUID NOT NULL REFERENCES ae.user (id) ON DELETE RESTRICT ON UPDATE CASCADE,
  terms_of_use text DEFAULT NULL,
  habitat_label varchar(50) DEFAULT NULL,
  habitat_comments text DEFAULT NULL,
  habitat_nr_fns_min integer DEFAULT NULL,
  habitat_nr_fns_max integer DEFAULT NULL,
  CONSTRAINT proper_links CHECK (length(regexp_replace(array_to_string(links, ''),'((([A-Za-z]{3,9}:(?:\/\/)?)(?:[-;:&=\+\$,\w]+@)?[A-Za-z0-9.-]+|(?:www.|[-;:&=\+\$,\w]+@)[A-Za-z0-9.-]+)((?:\/[\+~%\/.\w-_]*)?\??(?:[-\+=&;%@.\w_]*)#?(?:[\w]*))?)',''))=0)
);
CREATE INDEX ON ae.taxonomy USING btree (name);
CREATE INDEX ON ae.taxonomy USING btree (category);
CREATE POLICY
  taxonomy_reader
  ON ae.taxonomy
  FOR SELECT
  TO PUBLIC;
DROP POLICY IF EXISTS org_taxonomy_writer ON ae.object;
CREATE POLICY
  org_taxonomy_writer
  ON ae.taxonomy
  FOR ALL
  TO org_taxonomy_writer, org_admin
  USING (
    -- use 'show jwt.claims.user_id' instead of 'current_user'?
    current_user IN (
      SELECT
        cast(ae.organization_user.user_id as text)
      FROM
        ae.organization_user
        INNER JOIN ae.taxonomy
        ON ae.organization_user.organization_id = ae.taxonomy.organization_id
      WHERE
        ae.organization_user.organization_id = ae.taxonomy.organization_id AND
        ae.organization_user.role = 'orgTaxonomyWriter'
    )
  )
  WITH CHECK (
    current_user IN (
      SELECT
        cast(ae.organization_user.user_id as text)
      FROM
        ae.organization_user
        INNER JOIN ae.taxonomy
        ON ae.organization_user.organization_id = ae.taxonomy.organization_id
      WHERE
        ae.organization_user.organization_id = ae.taxonomy.organization_id AND
        ae.organization_user.role = 'orgTaxonomyWriter'
    )
  );

DROP TABLE IF EXISTS ae.user CASCADE;
CREATE TABLE ae.user (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v1mc(),
  name text NOT NULL UNIQUE,
  email text NOT NULL UNIQUE
);

DROP TABLE IF EXISTS ae.object CASCADE;
CREATE TABLE ae.object (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v1mc(),
  taxonomy_id UUID NOT NULL REFERENCES ae.taxonomy (id) ON DELETE CASCADE ON UPDATE CASCADE,
  -- need to temporarily turn off this reference because it is violated during import
  parent_id UUID DEFAULT NULL,-- REFERENCES ae.object (id) ON DELETE CASCADE ON UPDATE CASCADE,
  name text NOT NULL,
  properties jsonb DEFAULT NULL,
  category text DEFAULT NULL REFERENCES ae.category (name) ON UPDATE CASCADE,
  -- UUID's are by definition lowercase
  -- postgresql converts them to it
  -- see: https://www.postgresql.org/docs/9.6/static/datatype-uuid.html
  -- but UUID's generated by Access are uppercase!!!!
  -- so keep them around in the original form
  id_old text DEFAULT NULL
);
CREATE INDEX ON ae.object USING btree (name);
CREATE POLICY
  object_reader
  ON ae.object
  FOR SELECT
  TO PUBLIC;
DROP POLICY IF EXISTS org_object_writer ON ae.object;
CREATE POLICY
  org_object_writer
  ON ae.object
  FOR ALL
  TO org_taxonomy_writer, org_admin
  USING (
    current_user IN (
      SELECT
        cast(ae.organization_user.user_id as text)
      FROM
        ae.organization_user
        INNER JOIN ae.taxonomy
          INNER JOIN ae.object
          ON ae.taxonomy.id = ae.object.taxonomy_id
        ON ae.organization_user.organization_id = ae.taxonomy.organization_id
      WHERE
        ae.organization_user.organization_id = ae.taxonomy.organization_id AND
        ae.organization_user.role = 'orgTaxonomyWriter'
    )
  )
  WITH CHECK (
    current_user IN (
      SELECT
        cast(ae.organization_user.user_id as text)
      FROM
        ae.organization_user
        INNER JOIN ae.taxonomy
          INNER JOIN ae.object
          ON ae.taxonomy.id = ae.object.taxonomy_id
        ON ae.organization_user.organization_id = ae.taxonomy.organization_id
      WHERE
        ae.organization_user.organization_id = ae.taxonomy.organization_id AND
        ae.organization_user.role = 'orgTaxonomyWriter'
    )
  );

-- ae.object to ae.object relationship
-- best to add every relationship twice, see: https://stackoverflow.com/a/17128606/712005
DROP TABLE IF EXISTS ae.synonym CASCADE;
CREATE TABLE ae.synonym (
  object_id UUID NOT NULL REFERENCES ae.object (id) ON DELETE CASCADE ON UPDATE CASCADE,
  object_id_synonym UUID NOT NULL REFERENCES ae.object (id) ON DELETE CASCADE ON UPDATE CASCADE,
  PRIMARY KEY (object_id, object_id_synonym)
);
CREATE POLICY
  synonym_reader
  ON ae.synonym
  FOR SELECT
  TO PUBLIC;
DROP POLICY IF EXISTS org_synonym_writer ON ae.synonym;
CREATE POLICY
  org_synonym_writer
  ON ae.synonym
  FOR ALL
  TO org_taxonomy_writer, org_admin
  USING (
    current_user IN (
      SELECT
        cast(ae.organization_user.user_id as text)
      FROM
        ae.organization_user
        INNER JOIN ae.taxonomy
          INNER JOIN ae.object
            INNER JOIN ae.synonym
            ON ae.object.id = ae.synonym.object_id
          ON ae.taxonomy.id = ae.object.taxonomy_id
        ON ae.organization_user.organization_id = ae.taxonomy.organization_id
      WHERE
        ae.organization_user.organization_id = ae.taxonomy.organization_id AND
        ae.organization_user.role = 'orgTaxonomyWriter'
    )
  )
  WITH CHECK (
    current_user IN (
      SELECT
        cast(ae.organization_user.user_id as text)
      FROM
        ae.organization_user
        INNER JOIN ae.taxonomy
          INNER JOIN ae.object
            INNER JOIN ae.synonym
            ON ae.object.id = ae.synonym.object_id
          ON ae.taxonomy.id = ae.object.taxonomy_id
        ON ae.organization_user.organization_id = ae.taxonomy.organization_id
      WHERE
        ae.organization_user.organization_id = ae.taxonomy.organization_id AND
        ae.organization_user.role = 'orgTaxonomyWriter'
    )
  );

DROP TABLE IF EXISTS ae.property_collection CASCADE;
CREATE TABLE ae.property_collection (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v1mc(),
  data_type text DEFAULT 'Eigenschaften-Sammlungen' REFERENCES ae.data_type (name) ON DELETE SET NULL ON UPDATE CASCADE,
  -- later add UNIQUE
  name text NOT NULL,
  description text DEFAULT NULL,
  links text[] DEFAULT NULL,
  combining boolean DEFAULT FALSE,
  organization_id UUID NOT NULL REFERENCES ae.organization (id) ON DELETE SET NULL ON UPDATE CASCADE,
  last_updated date DEFAULT NULL,
  terms_of_use text DEFAULT NULL,
  imported_by UUID NOT NULL REFERENCES ae.user (id) ON DELETE RESTRICT ON UPDATE CASCADE
  --CONSTRAINT proper_links CHECK (length(regexp_replace(array_to_string(links, ''),'((([A-Za-z]{3,9}:(?:\/\/)?)(?:[-;:&=\+\$,\w]+@)?[A-Za-z0-9.-]+|(?:www.|[-;:&=\+\$,\w]+@)[A-Za-z0-9.-]+)((?:\/[\+~%\/.\w-_]*)?\??(?:[-\+=&;%@.\w_]*)#?(?:[\w]*))?)',''))=0)
);
CREATE INDEX ON ae.property_collection USING btree (name);
CREATE INDEX ON ae.property_collection USING btree (combining);
ALTER TABLE ae.property_collection ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS property_collection_reader ON ae.property_collection;
CREATE POLICY
  property_collection_reader
  ON ae.property_collection
  FOR SELECT
  TO PUBLIC;
DROP POLICY IF EXISTS property_org_collection_writer ON ae.property_collection;
CREATE POLICY
  property_org_collection_writer
  ON ae.property_collection
  FOR ALL
  TO org_collection_writer, org_admin
  USING (
    current_user IN (
      SELECT
        cast(ae.organization_user.user_id as text)
      FROM
        ae.organization_user
      WHERE
        ae.organization_user.organization_id = organization_id AND
        ae.organization_user.role = 'orgCollectionWriter'
    )
  )
  WITH CHECK (
    current_user IN (
      SELECT
        cast(ae.organization_user.user_id as text)
      FROM
        ae.organization_user
      WHERE
        ae.organization_user.organization_id = organization_id AND
        ae.organization_user.role = 'orgCollectionWriter'
    )
  );

DROP TABLE IF EXISTS ae.property_collection_object CASCADE;
CREATE TABLE ae.property_collection_object (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v1mc(),
  object_id UUID REFERENCES ae.object (id) ON DELETE CASCADE ON UPDATE CASCADE,
  property_collection_id UUID REFERENCES ae.property_collection (id) ON DELETE CASCADE ON UPDATE CASCADE,
  properties jsonb DEFAULT NULL,
  UNIQUE (object_id, property_collection_id)
);
ALTER TABLE ae.property_collection_object ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS property_collection_object_reader ON ae.property_collection_object;
CREATE POLICY
  property_collection_object_reader
  ON ae.property_collection_object
  FOR SELECT
  TO PUBLIC;
DROP POLICY IF EXISTS property_org_collection_object_writer ON ae.property_collection_object;
CREATE POLICY
  property_org_collection_object_writer
  ON ae.property_collection_object
  FOR ALL
  TO org_collection_writer, org_admin
  USING (
    current_user IN (
      SELECT
        cast(ae.organization_user.user_id as text)
      FROM
        ae.organization_user
      INNER JOIN
        (ae.property_collection
        INNER JOIN
          ae.property_collection_object
          ON property_collection_object.property_collection_id = ae.property_collection.id)
        ON ae.property_collection.organization_id = ae.organization_user.organization_id
      WHERE
        ae.property_collection_object.object_id = object_id AND
        ae.property_collection_object.property_collection_id = property_collection_id AND
        ae.organization_user.role = 'orgCollectionWriter'
    )
  )
  WITH CHECK (
    current_user IN (
      SELECT
        cast(ae.organization_user.user_id as text)
      FROM
        ae.organization_user
      INNER JOIN
        (ae.property_collection
        INNER JOIN
          ae.property_collection_object
          ON property_collection_object.property_collection_id = ae.property_collection.id)
        ON ae.property_collection.organization_id = ae.organization_user.organization_id
      WHERE
        ae.property_collection_object.object_id = object_id AND
        ae.property_collection_object.property_collection_id = property_collection_id AND
        ae.organization_user.role = 'orgCollectionWriter'
    )
  );

DROP TABLE IF EXISTS ae.relation CASCADE;
CREATE TABLE ae.relation (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v1mc(),
  property_collection_id UUID NOT NULL REFERENCES ae.property_collection (id) ON DELETE CASCADE ON UPDATE CASCADE,
  object_id UUID NOT NULL REFERENCES ae.object (id) ON DELETE CASCADE ON UPDATE CASCADE,
  object_id_relation UUID NOT NULL REFERENCES ae.object (id) ON DELETE CASCADE ON UPDATE CASCADE,
  relation_type text NOT NULL,
  properties jsonb DEFAULT NULL,
  UNIQUE (property_collection_id, object_id, object_id_relation, relation_type)
);
CREATE INDEX ON ae.relation USING btree (relation_type);
ALTER TABLE ae.relation ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS relation_reader ON ae.relation;
CREATE POLICY
  relation_reader
  ON ae.relation
  FOR SELECT
  TO PUBLIC;
DROP POLICY IF EXISTS relation_org_writer ON ae.relation;
CREATE POLICY
  relation_org_writer
  ON ae.relation
  FOR ALL
  TO org_collection_writer, org_admin
  USING (
    current_user IN (
      SELECT
        cast(ae.organization_user.user_id as text)
      FROM
        ae.organization_user
      INNER JOIN
        (ae.property_collection
        INNER JOIN
          (ae.property_collection_object
          INNER JOIN
            ae.relation
            ON ae.property_collection_object.id = ae.relation.property_collection_id)
          ON property_collection_object.property_collection_id = ae.property_collection.id)
        ON ae.property_collection.organization_id = ae.organization_user.organization_id
      WHERE
        ae.relation.id = id AND
        ae.organization_user.role = 'orgCollectionWriter'
    )
  )
  WITH CHECK (
    current_user IN (
      SELECT
        cast(ae.organization_user.user_id as text)
      FROM
        ae.organization_user
      INNER JOIN
        (ae.property_collection
        INNER JOIN
          (ae.property_collection_object
          INNER JOIN
            ae.relation
            ON ae.property_collection_object.id = ae.relation.property_collection_id)
          ON property_collection_object.property_collection_id = ae.property_collection.id)
        ON ae.property_collection.organization_id = ae.organization_user.organization_id
      WHERE
        ae.relation.id = id AND
        ae.organization_user.role = 'orgCollectionWriter'
    )
  );

DROP TABLE IF EXISTS ae.role CASCADE;
CREATE TABLE ae.role (
  name text PRIMARY KEY
);

DROP TABLE IF EXISTS ae.organization_user;
CREATE TABLE ae.organization_user (
  organization_id UUID REFERENCES ae.organization (id) ON DELETE CASCADE ON UPDATE CASCADE,
  user_id UUID REFERENCES ae.user (id) ON DELETE CASCADE ON UPDATE CASCADE,
  role text REFERENCES ae.role (name) ON DELETE CASCADE ON UPDATE CASCADE,
  PRIMARY KEY (organization_id, user_id, role)
);

-- this table is only needed because postgraphql does not pick up
-- the same named function without it
-- see: https://github.com/postgraphql/postgraphql/issues/491
DROP TABLE IF EXISTS ae.tax_properties_by_category CASCADE;

-- this table is only needed because postgraphql does not pick up
-- the same named function without it
-- see: https://github.com/postgraphql/postgraphql/issues/491
DROP TABLE IF EXISTS ae.tax_properties_by_taxonomy CASCADE;
CREATE TABLE ae.tax_properties_by_taxonomy (
  taxonomy_name text,
  property_name text,
  jsontype text,
  count bigint
);

-- TODO: remove after replacing with ...by_taxonomy
DROP TABLE IF EXISTS ae.pco_properties_by_category CASCADE;

-- this table is only needed because postgraphql does not pick up
-- the same named function without it
-- see: https://github.com/postgraphql/postgraphql/issues/491
DROP TABLE IF EXISTS ae.pco_properties_by_taxonomy CASCADE;
CREATE TABLE ae.pco_properties_by_taxonomy (
  property_collection_name text,
  property_name text,
  jsontype text,
  count bigint
);

DROP TABLE IF EXISTS ae.rco_properties_by_category CASCADE;

-- this table is only needed because postgraphql does not pick up
-- the same named function without it
-- see: https://github.com/postgraphql/postgraphql/issues/491
DROP TABLE IF EXISTS ae.rco_properties_by_taxonomy CASCADE;
CREATE TABLE ae.rco_properties_by_taxonomy (
  property_collection_name text,
  relation_type text,
  property_name text,
  jsontype text,
  count bigint
);

-- this table is only needed because postgraphql does not pick up
-- the same named function without it
-- see: https://github.com/postgraphql/postgraphql/issues/491
DROP TABLE IF EXISTS ae.categories_of_taxonomies CASCADE;
CREATE TABLE ae.categories_of_taxonomies (
  name text,
  id uuid,
  count bigint
);

-- this table is only needed because postgraphql does not pick up
-- the same named function without it
-- see: https://github.com/postgraphql/postgraphql/issues/491
DROP TABLE IF EXISTS ae.taxonomies_of_category CASCADE;
CREATE TABLE ae.taxonomies_of_category (
  category_name text,
  taxonomy_name text,
  object_count bigint
);

-- drop old tables
DROP TABLE IF EXISTS ae.taxonomy_object CASCADE;
